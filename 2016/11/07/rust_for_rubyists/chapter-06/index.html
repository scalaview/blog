<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>王见充时光</title>
  <meta name="author" content="Benko bin">
  
  <meta name="description" content="Tasks in RustWarning: The Rust libraries that implement threading are consideredunstable (Rust 0.12).
One of the things that Rust is super good at is ">
  
  
  
  <meta property="og:site_name" content="王见充时光"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta property="og:image" content="undefined"/>
  
   <link rel="apple-touch-icon" href="/icon.png" />
   <link rel="shortcut icon" href="/favicon.ico" >
   <link rel="alternate" href="http://xxx.xx/atom.xml" title="王见充时光" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.3.min.js"></script>
</head>


<body>
  <div id="content" class="inner">
    <aside id="sidebar" class="alignleft">
      <div class="navigationBar">
        <a href="/">王见充时光</a>
      </div>
    	
  <nav class="widget" id="menu">
	<ul>
    
      <li class="cell"><a class="next" href="/">Home</a><li>
    
      <li class="cell"><a class="next" href="/archives/">Archives</a><li>
    
      <li class="cell"><a class="next" href="/about/">About</a><li>
    
      <li class="cell"><a class="next" href="/atom.xml">Subscribe</a><li>
    
    </ul>
</nav>

  

  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/Android/" style="font-size: 20px;">Android</a><a href="/tags/Data-Storage/" style="font-size: 10px;">Data Storage</a><a href="/tags/Java/" style="font-size: 15px;">Java</a><a href="/tags/Jquery/" style="font-size: 10px;">Jquery</a><a href="/tags/RecyclerView/" style="font-size: 10px;">RecyclerView</a><a href="/tags/Service/" style="font-size: 10px;">Service</a><a href="/tags/Thread/" style="font-size: 10px;">Thread</a><a href="/tags/listView/" style="font-size: 10px;">listView</a><a href="/tags/优化/" style="font-size: 10px;">优化</a>
  </div>
</div>


    	<footer id="footer" class="inner"><div class="copyright">
  
  &copy; 2016 Benko bin
  
</div>



</footer>
    </aside>
    
    
    <div id="hidden-navigationBar" class="navigationBar">
      <a href="/">王见充时光</a>
    </div>
    <div id="main-col" class="alignright">
    <div id="wrapper">
      
<article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
  <header>
      
      
  
    <h1 class="title"></h1>
  

      <time datetime="2016-11-07T02:53:24.064Z"><a href="/2016/11/07/rust_for_rubyists/chapter-06/">2016-11-07</a></time>
      
  </header>
    <div class="entry">
      
        <h1 id="Tasks_in_Rust">Tasks in Rust</h1><p><strong>Warning:</strong> The Rust libraries that implement threading are considered<br>unstable (Rust 0.12).</p>
<p>One of the things that Rust is super good at is concurrency. In order to<br>understand Rust’s strengths, you have to understand its approach to<br>concurrency, and then its approach to memory.</p>
<h2 id="Tasks">Tasks</h2><p>The fundamental unit of computation in Rust is called a ‘task.’ Tasks are like<br>threads, but you can choose the low-level details of how they operate. Rust now<br>supports both 1:1 scheduled and N:M scheduled threads. Rust uses 1:1 threads by<br>default.  The details of what <em>exactly</em> that means are out of the scope of this<br>tutorial, but the <a href="http://en.wikipedia.org/wiki/Thread_%28computing%29" target="_blank" rel="external">Wikipedia<br>page</a> has a good overview.</p>
<p>Here’s some code that prints “Hello” 500 times:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">0</span>u, <span class="number">500</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You may remember this from earlier. This loops 500 times, printing<br>“Hello.” Now let’s make it roflscale with tasks:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread::Thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">0</span>u, <span class="number">500</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = Thread::spawn(move || &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That’s it! We spin up 500 tasks that print stuff. If you inspect your<br>output, you can tell it’s working:</p>
<pre><code><span class="title">Hello</span>
HelloHello

Hello
</code></pre><p>Ha! </p>
<p>A few notes: </p>
<ul>
<li><p>The <code>use</code> statement imports other modules. Here we use <code>spawn</code>, which is<br>part of the Rust standard library: <code>std::thread</code>. It is similar to Ruby’s<br><code>require</code> or <code>include</code>. You can read more about how <code>use</code> works [here]<br>(<a href="http://doc.rust-lang.org/reference.html#use-declarations" target="_blank" rel="external">http://doc.rust-lang.org/reference.html#use-declarations</a>).</p>
</li>
<li><p>By default, threads must return a value or the compiler will complain.<br><code>let _</code> assigns the thread’s return value to a throwaway variable. There<br>will still be a compiler warning because the variable <code>num</code> is never used,<br>but we can also fix that by replacing <code>num</code> with <code>_</code>. Try it!</p>
</li>
</ul>
<p>Printing to the screen is obviously something that tasks can step<br>over each other with (if you’re curious, it’s because it is printing the<br>string and the newline separately. Sometimes, another task gets to print<br>its string before this task prints its newline). But the vast majority<br>of things aren’t like that. Let’s take a look at the type signature of<br><code>spawn</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>(f: <span class="keyword">proc</span>())</span><br></pre></td></tr></table></figure>
<p>Spawn is a function that takes a proc: a closure that can only be run once.<br>This means that Rust can do what it wants, moving the closure to another task,<br>or other optimizations. The details aren’t particularly important at this<br>stage, and Rust will be undergoing some reform with regards to closures soon,<br>so just think of it as a closure, and that’s good enough.</p>
<h2 id="Pipes,_Channels,_and_Ports">Pipes, Channels, and Ports</h2><p>If our tasks are 100% isolated, they wouldn’t be that useful: we need some kind<br>of communication between tasks in order to get back useful results. We can<br>communicate between tasks with pipes. Pipes have two ends: a channel that sends<br>info down the pipe, and a port that receives info. If you’ve used these<br>concepts in other languages, Rust’s are similar, except that Rust’s are<br>explicitly typed. Some implementations of this pattern in other languages do<br>not make this distinction. Otherwise, they’re very similar.</p>
<p>Here’s an example of a task that sends us back a 10:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (chan, port) = channel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _ = Thread::spawn(move || &#123;</span><br><span class="line">        chan.send(<span class="number">10</span>u);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, port.recv().to_string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>channel</code> function, imported by the prelude, creates both sides of this<br>pipe. You can imagine that instead of sending 10, we might be doing some sort<br>of complex calculation. It could be doing that work in the background while we<br>did more important things.</p>
<p>What about that <code>chan.send</code> bit? Well, the task captures the <code>chan</code><br>variable we set up before, so it’s just matter of using it. This is<br>similar to Ruby’s blocks:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="number">10</span></span><br><span class="line"><span class="number">2</span>.times <span class="keyword">do</span></span><br><span class="line">  puts foo</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>This is really only one-way transit, though: what if we want to<br>communicate back and forth? Setting up two ports and channels each time<br>would be pretty annoying, so we have some standard library code for<br>this.</p>
<p>We make a function that just loops forever, gets an <code>int</code> off of the<br>port, and sends the number plus 1 back down the channel. In the main<br>function, we make a channel, send one end to a new task, and then<br>send it a <code>22</code>, and print out the result. Because this task is running<br>in the background, we can send it bunches of values:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread::Thread;</span><br><span class="line"><span class="keyword">use</span> std::comm::&#123;channel, Sender, Receiver&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(sender: &amp;Sender&lt;<span class="keyword">int</span>&gt;, receiver: &amp;Receiver&lt;<span class="keyword">int</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> value: <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        value = receiver.recv();</span><br><span class="line">        sender.send(value + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> value == <span class="number">0</span> &#123; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (from_parent_sender, from_parent_receiver) = channel();</span><br><span class="line">    <span class="keyword">let</span> (from_child_sender, from_child_receiver) = channel();</span><br><span class="line"></span><br><span class="line">    from_parent_sender.send(<span class="number">22</span>);</span><br><span class="line">    from_parent_sender.send(<span class="number">23</span>);</span><br><span class="line">    from_parent_sender.send(<span class="number">24</span>);</span><br><span class="line">    from_parent_sender.send(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _ = Thread::spawn(move || &#123;</span><br><span class="line">        plus_one(&amp;from_child_sender, &amp;from_parent_receiver);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">0</span>i, <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> answer = from_child_receiver.recv();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, answer.to_string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pretty simple. Our task is always waiting for work. If you run this,<br>you’ll get some weird output at the end:</p>
<pre><code><span class="variable">$ </span>rustc tasks.rs &amp;&amp; ./tasks
<span class="number">23</span>
<span class="number">24</span>
<span class="number">25</span>
<span class="number">26</span>
task <span class="string">'&lt;unnamed&gt;'</span> failed at <span class="string">'receiving on a closed channel'</span>, <span class="regexp">/home/steveklabnik</span><span class="regexp">/src/rust</span><span class="regexp">/src/libstd</span><span class="regexp">/comm/mod</span>.<span class="symbol">rs:</span><span class="number">728</span>
</code></pre><p><code>task failed at &#39;receiving on closed channel&#39;</code>. Basically, we quit the program<br>without closing our child task, and so it died when our main task (the one<br>running <code>main</code>) died. By default, Rust tasks are bidirectionally linked, which<br>means if one task fails, all of its children and parents fail too. We can fix<br>this for now by telling our child to die:</p>
<p><strong> Warning </strong> Unsure of the behavior as to the above program in Rust 0.13 because<br>the child task is never closed. </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread::Thread;</span><br><span class="line"><span class="keyword">use</span> std::comm::&#123;channel, Sender, Receiver&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(sender: &amp;Sender&lt;<span class="keyword">int</span>&gt;, receiver: &amp;Receiver&lt;<span class="keyword">int</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> value: <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        value = receiver.recv();</span><br><span class="line">        sender.send(value + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> value == <span class="number">0</span> &#123; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (from_parent_sender, from_parent_receiver) = channel();</span><br><span class="line">    <span class="keyword">let</span> (from_child_sender, from_child_receiver) = channel();</span><br><span class="line"></span><br><span class="line">    from_parent_sender.send(<span class="number">22</span>);</span><br><span class="line">    from_parent_sender.send(<span class="number">23</span>);</span><br><span class="line">    from_parent_sender.send(<span class="number">24</span>);</span><br><span class="line">    from_parent_sender.send(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    from_parent_sender.send(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _ = Thread::spawn(move || &#123;</span><br><span class="line">        plus_one(&amp;from_child_sender, &amp;from_parent_receiver);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">0</span>i, <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> answer = from_child_receiver.recv();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, answer.to_string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now when we send a zero, our child task terminates. If you run this,<br>you’ll get no errors at the end. We can also change our failure mode.<br>Rust also provides unidirectional and unlinked failure modes as well,<br>but I don’t want to talk about them right now. This would give you<br>patterns like “Spin up a management task that is bidirectionally linked<br>to main, but have it spin up children who are unlinked.” Neato.</p>
<p>Rust tasks are so lightweight that you can conceivably spin up a ton of<br>tasks, maybe even one per entity in your system.<br><a href="https://github.com/mozilla/servo" target="_blank" rel="external">Servo</a> is a prototype browser<br>rendering engine from Mozilla, and it spins up a <strong>ton</strong> of tasks.<br>Parallel rendering, parsing, downloading, everything.</p>
<p>I’m imagining that most production Rust programs will eventually have a<br>main that spins up some sort of global task setup, and all the work gets<br>done inside these tasks that communicate with each other. Like, for a<br>video game:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    spawn(<span class="keyword">proc</span>() &#123;</span><br><span class="line">        player_handler();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    spawn(<span class="keyword">proc</span>() &#123;</span><br><span class="line">        world_handler();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    spawn(<span class="keyword">proc</span>() &#123;</span><br><span class="line">        rendering_handler();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    spawn(<span class="keyword">proc</span>() &#123;</span><br><span class="line">        io_handler();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>… with the associated channels, of course. This feels very Actor-y to<br>me. I like it.</p>

	     
	         <p style="margin:20px 0; color:#9f9f9f; font-size:12px;">
<span>Posted by <a style="color:#9f9f9f;" href="https://github.com/scalaview"><strong>scalaview</strong></a> - 2016-11-07</span><br />
<span style="line-height:13px;">如需转载，请注明： 本文来自 <a style="color:#9f9f9f;" href="http://scalaview.github.io"><strong>王见充时光</strong></a></span>
</p>
       	
      
    </div>
    <footer>
      
	 
     		  
       		
     		  
       	 
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-rust_for_rubyists/chapter-06" data-title="" data-url="http://scalaview.github.io/2016/11/07/rust_for_rubyists/chapter-06/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'scalaview'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
</div>
    </div>
    <div class="tabbar" onload="divideTabBar()">
	
      <div class="tabbaritem"><a class="next" href="/">Home</a></div>
    
      <div class="tabbaritem"><a class="next" href="/archives/">Archives</a></div>
    
      <div class="tabbaritem"><a class="next" href="/about/">About</a></div>
    
      <div class="tabbaritem"><a class="next" href="/atom.xml">Subscribe</a></div>
    
</div>


  </div>
</body>
</html>